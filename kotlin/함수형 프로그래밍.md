# 함수형 프로그래밍

> 함수형 프로그래밍은 현대 소프트웨어 개발에서 가장 중요한 패러다임 중 하나입니다.  
> 전통적인 방식(명령형)은 "양파를 썰고, 당근을 썰고, 팬에 기름을 두르고..."처럼  
> 단계별로 무엇을 할지 명령하는 방식입니다.  
> 
> 반면 함수형 방식은 "재료를 준비하고, 조리하고, 플레이팅한다"처럼  
> **무엇을 만들 것인지**에 집중하는 방식입니다.  
> 각 단계는 독립적이고, 같은 재료로는 항상 같은 결과가 나오며,  
> 요리 과정에서 주방의 다른 부분을 건드리지 않습니다.  
> 
> 함수형 프로그래밍은 순수 함수를 조합하고 공유 상태, 변경 가능한 데이터 및 부작용을 피해 개발하는 방법을 이야기 합니다.
> 이 글에서는 함수형 프로그래밍이 무엇인지, 어떤 조건을 갖추어야 하는지 정리합니다.

---

## 1. 함수형 프로그래밍이란?

### 기본 개념
함수형 프로그래밍은 프로그래밍 언어나 방식을 배우는 것이 아닌, **함수로 프로그래밍하는 사고를 배우는 것**입니다.  
기존의 사고방식을 전환하여 프로그래밍을 더 유연하게 문제해결하도록 접근하는 것입니다.

### 명령형 vs 선언형 프로그래밍

#### 명령형 프로그래밍 (Imperative Programming)
- **절차지향, 객체지향** 프로그래밍 방식
- 상태와 상태를 변경시키는 관점에서 연산을 설명
- **How(어떻게)** 할지 표현
- 알고리즘을 명시하고, 목표는 명시하지 않음

```kotlin
// 명령형 프로그래밍 예시
val numbers = listOf(1, 2, 3, 4, 5)
val evenNumbers = mutableListOf<Int>()

for (i in numbers.indices) {
    if (numbers[i] % 2 == 0) {
        evenNumbers.add(numbers[i])
    }
}
```

#### 선언형 프로그래밍 (Declarative Programming)
- **함수형 프로그래밍**의 핵심
- **What(무엇을)** 할 건지 설명하는 방식
- 알고리즘을 명시하지 않고 목표만 명시
- 더 간결하고 예측 가능한 코드

```kotlin
// 선언형 프로그래밍 예시
val numbers = listOf(1, 2, 3, 4, 5)
val evenNumbers = numbers.filter { it % 2 == 0 }
```

---

## 2. 함수형 프로그래밍의 핵심 개념

### 순수 함수 (Pure Functions)
입출력이 순수해야 합니다:
- 반드시 하나 이상의 인자를 받고, 받은 인자를 처리해 반드시 결과물을 돌려줘야 함
- 인자 외 다른 변수 사용 금지
- 같은 입력에 대해 항상 같은 출력을 보장

```kotlin
// 순수 함수
fun add(a: Int, b: Int): Int = a + b

// 순수 함수가 아님
var globalValue = 10
fun addWithGlobal(a: Int): Int = a + globalValue
```

### 합성 함수 (Function Composition)
여러 함수를 조합하여 새로운 함수를 만드는 것

```kotlin
fun addOne(x: Int): Int = x + 1
fun multiplyByTwo(x: Int): Int = x * 2
fun addOneThenMultiplyByTwo(x: Int): Int = multiplyByTwo(addOne(x))

// 또는 함수 합성 연산자 사용
val composedFunction = ::addOne andThen ::multiplyByTwo
```

### 공유 상태 피하기 (Avoid Shared State)
전역 변수나 공유 객체의 상태를 변경하지 않기

```kotlin
// 공유 상태 사용
object Calculator {
    var result = 0
    
    fun add(x: Int) {
        result += x
    }
}

// 공유 상태 없이
class Calculator {
    fun add(a: Int, b: Int): Int = a + b
}
```

### 상태 변화 피하기 (Avoid Mutating State)
원본 데이터는 절대 불변! 새로운 데이터를 생성

```kotlin
// 상태 변경
val numbers = mutableListOf(1, 2, 3)
numbers.add(4)

// 불변 상태
val numbers = listOf(1, 2, 3)
val newNumbers = numbers + 4
```

### 부작용 피하기 (Avoid Side Effects)
함수 외부의 상태를 변경하지 않기

```kotlin
// 부작용 있음
fun processUser(user: User) {
    user.name = user.name.uppercase() // 외부 객체 상태 변경
    println("Processed: ${user.name}") // 외부 출력
}

// 부작용 없음
fun processUser(user: User): User {
    return user.copy(name = user.name.uppercase())
}
```

---

## 3. 함수형 프로그래밍의 장단점

### 장점
1. **예측 가능성**: 같은 입력에 항상 같은 출력
2. **테스트 용이성**: 순수 함수는 독립적으로 테스트 가능
3. **병렬 처리**: 부작용이 없어 동시 실행에 안전
4. **코드 가독성**: 의도가 명확하게 드러남
5. **버그 감소**: 상태 변경으로 인한 예상치 못한 버그 방지

### 단점
1. **학습 곡선**: 기존 명령형 사고방식에서 전환 필요
2. **성능 오버헤드**: 불변 객체 생성으로 인한 메모리 사용량 증가
3. **디버깅 복잡성**: 함수 호출 체인 추적이 어려울 수 있음
4. **적용 범위**: 모든 문제에 적합하지 않을 수 있음

---

## 4. Kotlin에서의 함수형 프로그래밍

### 고차 함수 (Higher-Order Functions)
함수를 매개변수로 받거나 함수를 반환하는 함수

```kotlin
fun <T> List<T>.customFilter(predicate: (T) -> Boolean): List<T> {
    val result = mutableListOf<T>()
    for (item in this) {
        if (predicate(item)) {
            result.add(item)
        }
    }
    return result
}

// 사용 예시
val numbers = listOf(1, 2, 3, 4, 5)
val evenNumbers = numbers.customFilter { it % 2 == 0 }
```

### 람다와 익명 함수
간결한 함수 표현

```kotlin
// 람다 표현식
val add: (Int, Int) -> Int = { a, b -> a + b }

// 익명 함수
val multiply = fun(a: Int, b: Int): Int = a * b

// 사용
println(add(5, 3)) // 8
println(multiply(4, 2)) // 8
```

### 확장 함수
기존 클래스에 새로운 기능을 추가

```kotlin
fun String.isPalindrome(): Boolean {
    return this == this.reversed()
}

fun String.toTitleCase(): String {
    return this.split(" ").joinToString(" ") { word ->
        word.replaceFirstChar { it.uppercase() }
    }
}

// 사용
val text = "racecar"
println(text.isPalindrome()) // true

val title = "hello world"
println(title.toTitleCase()) // Hello World
```

### 컬렉션 함수형 API
Kotlin의 강력한 컬렉션 처리 기능

```kotlin
val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

// 체이닝을 통한 함수형 처리
val result = numbers
    .filter { it % 2 == 0 }        // 짝수만 필터링
    .map { it * it }               // 제곱
    .take(3)                       // 처음 3개만
    .sum()                         // 합계

println(result) // 4 + 16 + 36 = 56
```

---

## 5. Android 개발에서의 활용

### ViewModel에서의 상태 관리
```kotlin
class UserViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(UserUiState())
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
    
    // 순수 함수로 상태 변환
    fun updateUserName(newName: String) {
        _uiState.value = _uiState.value.copy(
            userName = newName,
            isNameValid = newName.length >= 2
        )
    }
    
    // 부작용 없는 데이터 처리
    fun processUserData(users: List<User>): List<UserDisplay> {
        return users
            .filter { it.isActive }
            .map { user ->
                UserDisplay(
                    id = user.id,
                    displayName = user.name.uppercase(),
                    age = calculateAge(user.birthDate)
                )
            }
            .sortedBy { it.displayName }
    }
    
    private fun calculateAge(birthDate: LocalDate): Int {
        return Period.between(birthDate, LocalDate.now()).years
    }
}
```

### Repository 패턴에서의 활용
```kotlin
class UserRepository @Inject constructor(
    private val userDao: UserDao,
    private val userApi: UserApi
) {
    // 순수 함수로 데이터 변환
    fun getUserDisplayData(user: User): UserDisplay {
        return UserDisplay(
            id = user.id,
            name = user.name.trim(),
            email = user.email.lowercase(),
            isVerified = user.email.isNotEmpty() && user.email.contains("@")
        )
    }
    
    // 부작용 없는 데이터 필터링
    fun getActiveUsers(users: List<User>): List<User> {
        return users.filter { user ->
            user.isActive && user.lastLoginDate.isAfter(LocalDateTime.now().minusDays(30))
        }
    }
    
    suspend fun fetchAndProcessUsers(): Flow<List<UserDisplay>> {
        return userApi.getUsers()
            .map { users ->
                users.map { getUserDisplayData(it) }
            }
            .map { users ->
                getActiveUsers(users)
            }
    }
}
```

### UI 이벤트 처리
```kotlin
class MainActivity : AppCompatActivity() {
    private val viewModel: MainViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // 함수형 이벤트 처리
        setupEventHandlers()
        observeViewModel()
    }
    
    private fun setupEventHandlers() {
        binding.buttonSubmit.setOnClickListener {
            val input = binding.editTextInput.text.toString()
            viewModel.processInput(input)
        }
    }
    
    private fun observeViewModel() {
        lifecycleScope.launch {
            viewModel.uiState
                .map { it.isLoading }           // 로딩 상태만 추출
                .distinctUntilChanged()         // 중복 제거
                .collect { isLoading ->
                    updateLoadingState(isLoading)
                }
        }
    }
    
    private fun updateLoadingState(isLoading: Boolean) {
        binding.progressBar.isVisible = isLoading
        binding.buttonSubmit.isEnabled = !isLoading
    }
}
```

---

## 참고 자료
- [Kotlin 공식 문서 - 함수형 프로그래밍](https://kotlinlang.org/docs/fun-interfaces.html)
- [Android 개발자 가이드 - 아키텍처 컴포넌트](https://developer.android.com/topic/libraries/architecture)
- [Clean Architecture - Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
