# 코틀린 프로퍼티

> 코틀린 프로퍼티의 개념과 자바와의 차이점, 배킹 필드, `var`와 `val`의 차이, 그리고 `const val`의 개념까지 정리합니다.  
> 자바와 비교하여 코틀린 프로퍼티가 어떤 차이를 가지는지 알아봅니다.

## 1. 코틀린 프로퍼티란?

코틀린에서의 **프로퍼티(property)** 는 변수와 그에 대한 접근자(getter/setter)를 포함하는 개념입니다.  
자바에서는 필드(field)와 메서드로 나뉘지만, 코틀린은 이를 하나의 프로퍼티로 통합하여 간결하고 명확한 코드를 작성할 수 있게 합니다.

```kotlin
class Person {
    var name: String = "신짱구"
}
```

위의 코드는 자바로 변환하면 다음과 같습니다.

```java
public class Person {
    private String name = "신짱구";

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

코틀린은 자동으로 getter와 setter를 생성해주기 때문에, 개발자가 직접 작성할 필요가 없습니다.

---

## 2. 자바 필드와 코틀린 프로퍼티의 차이점

| 항목 | 자바 (Java) | 코틀린 (Kotlin) |
|------|-------------|-----------------|
| 기본 구성 | 필드 + 메서드 | 프로퍼티 (필드 + 접근자) |
| 접근자 | 수동으로 작성 | 자동 생성 |
| 불변성 지원 | `final` 키워드 사용 | `val` 키워드 사용 |
| 코드 간결성 | 보일러플레이트 코드 많음 | 간결하고 명확함 |

코틀린의 프로퍼티는 자바의 필드보다 더 강력하고 유연한 기능을 제공합니다.  
특히, 커스텀 접근자를 통해 로직을 추가하거나, 접근 제한자를 설정하는 등 다양한 활용이 가능합니다.

---

## 3. 배킹 필드(Backing Field)란?

프로퍼티의 값을 저장하기 위해 코틀린은 **배킹 필드(backing field)**를 사용합니다.   
이는 프로퍼티 내부에서 `field` 키워드를 통해 접근할 수 있습니다.    
커스텀 접근자를 작성할 때, 직접 프로퍼티를 참조하면 무한 재귀 호출이 발생할 수 있으므로 `field`를 사용하여 이를 방지해야 합니다.  

```kotlin
var age: Int = 0
    set(value) {
        if (value >= 0) field = value
    }
```

위의 코드에서 `field`는 `age` 프로퍼티의 실제 저장 공간을 의미합니다.  
만약 `field` 대신 `age`를 사용하면 setter가 자기 자신을 계속 호출하게 되어 StackOverflowError가 발생할 수 있습니다.  

배킹 필드는 다음과 같은 경우에 자동으로 생성됩니다.

- 기본 getter 또는 setter를 사용하는 경우
- 커스텀 접근자에서 `field`를 참조하는 경우

다음과 같은 경우에는 배킹 필드가 생성되지 않습니다.

- 인터페이스에서 선언된 프로퍼티
- `abstract`로 선언된 프로퍼티
- 커스텀 getter만 존재하고 `field`를 참조하지 않는 경우

---

## 4. `val` vs `var` 차이점

코틀린에서는 변수를 선언할 때 `val`과 `var`를 사용합니다. 이 둘의 가장 큰 차이점은 **불변성**입니다.

| 키워드 | 설명 | 재할당 여부 |
|--------|------|-------------|
| `val` | 불변 변수 (읽기 전용) | 불가능 |
| `var` | 가변 변수 | 가능 |

예를 들면 다음과 같습니다.

```kotlin
val name = "신짱구"
name = "흰둥이" // 컴파일 에러 발생

var age = 23
age = 24 // 정상 작동
```

`val`은 한 번 값을 할당하면 변경할 수 없습니다.  
이는 자바의 `final` 키워드와 유사합니다. 반면에 `var`는 값을 자유롭게 변경할 수 있습니다.  

일반적으로, 가능한 한 `val`을 사용하여 불변성을 유지하는 것이 좋으며, 꼭 필요한 경우에만 `var`를 사용하는 것이 권장됩니다.   
이는 코드의 안정성과 예측 가능성을 높이는 데 도움이 됩니다.

---

## 5. `const val`이란?

코틀린에서는 `val` 키워드를 사용하면 **런타임 시점에** 초기화되는 불변 변수를 만들 수 있습니다.  
반면에 `const val`은 **컴파일 시점에** 값을 결정하는 상수를 정의할 때 사용합니다.  

- `const val`은 **기본 타입**(String, Int, 등)만 사용할 수 있습니다.
- `const val`은 클래스의 최상위 레벨이나 `object`, `companion object` 내부에서만 사용할 수 있습니다.

예를 들면 다음과 같습니다.

```kotlin
const val APP_NAME = "MyApplication"

val today = LocalDate.now() // const val로는 불가능
```

`const val`은 코드가 컴파일될 때 값이 이미 결정되므로, 성능 측면에서도 유리하고, 자바 코드와의 상호운용성에도 도움이 됩니다.  
예를 들어, 자바에서는 `public static final` 상수로 인식됩니다.

`val`과 `const val`의 차이는 다음과 같습니다.

| 키워드     | 초기화 시점 | 사용 가능한 타입 | 위치                 |
|------------|-------------|------------------|----------------------|
| `val`      | 런타임       | 모든 타입         | 어디서나 가능         |
| `const val`| 컴파일타임   | 기본 타입만       | 최상위 레벨 또는 객체 안 |

따라서 프로그램 상에서 변하지 않는 고정값(예: `API_KEY`, `VERSION_NAME` 등)은 `const val`로 선언하는 것을 권장합니다.
