# 얕은 복사와 깊은 복사

> **얕은 복사(Shallow Copy)** 와 **깊은 복사(Deep Copy)** 는 객체나 배열을 복사할 때 나타나는 두 가지 서로 다른 복사 방식입니다.  
> 안드로이드 개발에서 데이터 불변성과 상태 관리에 대한 개념입니다.

---

## 1. 얕은 복사와 깊은 복사의 차이점

### 얕은 복사 (Shallow Copy)
```kotlin
// 얕은 복사 - 참조만 복사
data class Address(var city: String, var zipCode: String)
data class Person(var name: String, var address: Address)

val originalPerson = Person("신짱구", Address("떡잎마을", "12345"))
val shallowCopy = originalPerson.copy()

// 중첩된 객체는 같은 참조를 공유
shallowCopy.address.city = "부산"
println(originalPerson.address.city)  // "부산" - 원본도 변경됨!
```

### 깊은 복사 (Deep Copy)
```kotlin
// 깊은 복사 - 모든 중첩된 객체까지 새로 생성
val deepCopy = Person(
    name = originalPerson.name,
    address = Address(
        city = originalPerson.address.city,
        zipCode = originalPerson.address.zipCode
    )
)

deepCopy.address.city = "대구"
println(originalPerson.address.city)  // "떡잎마을" - 원본은 변경되지 않음
```

---

## 2. Kotlin에서의 얕은 복사

### 데이터 클래스의 copy() 함수
```kotlin
data class User(
    val id: Long,
    val name: String,
    val preferences: MutableMap<String, String>
)

val originalUser = User(
    id = 1L,
    name = "신짱구",
    preferences = mutableMapOf("theme" to "dark", "language" to "ko")
)

// copy() 함수는 얕은 복사
val copiedUser = originalUser.copy(name = "신형만")

// preferences는 같은 참조를 공유
copiedUser.preferences["theme"] = "light"
println(originalUser.preferences["theme"])  // "light" - 원본도 변경됨
```

### 컬렉션의 얕은 복사
```kotlin
// 리스트의 얕은 복사
val originalList = mutableListOf(
    Address("떡잎마을", "12345"),
    Address("액션가면마을", "67890")
)

val shallowCopyList = originalList.toMutableList()  // 얕은 복사

// 리스트는 다르지만 내부 객체는 같은 참조
shallowCopyList[0].city = "짱아마을"
println(originalList[0].city)  // "짱아마을" - 원본 리스트의 객체도 변경됨

// Map의 얕은 복사
val originalMap = mutableMapOf(
    "user1" to Person("신짱구", Address("떡잎마을", "12345"))
)
val shallowCopyMap = originalMap.toMutableMap()

shallowCopyMap["user1"]?.address?.city = "흰둥이마을"
println(originalMap["user1"]?.address?.city)  // "흰둥이마을" - 원본도 변경됨
```

---

## 3. Kotlin에서의 깊은 복사

### 수동 깊은 복사 구현
```kotlin
// 깊은 복사 함수를 추가한 Address와 Person 클래스
data class Address(var city: String, var zipCode: String) {
    fun deepCopy(): Address {
        return Address(city, zipCode)
    }
}

data class Person(var name: String, var address: Address) {
    fun deepCopy(): Person {
        return Person(name, address.deepCopy())
    }
}

// 사용
val original = Person("신짱구", Address("떡잎마을", "12345"))
val deepCopy = original.deepCopy()

deepCopy.address.city = "부산"
println(original.address.city)  // "떡잎마을" - 원본 유지
```

### 제네릭을 활용한 깊은 복사
```kotlin
interface DeepCopyable<T> {
    fun deepCopy(): T
}

data class User(
    val id: Long,
    val name: String,
    val settings: UserSettings
) : DeepCopyable<User> {
    override fun deepCopy(): User {
        return User(id, name, settings.deepCopy())
    }
}

data class UserSettings(
    var theme: String,
    var notifications: MutableList<String>
) : DeepCopyable<UserSettings> {
    override fun deepCopy(): UserSettings {
        return UserSettings(
            theme = theme,
            notifications = notifications.toMutableList()
        )
    }
}
```

### 직렬화를 이용한 깊은 복사
```kotlin
import kotlinx.serialization.*
import kotlinx.serialization.json.*

@Serializable
data class SerializableUser(
    val id: Long,
    val name: String,
    val metadata: Map<String, String>
)

fun <T> T.deepCopyWithSerialization(): T where T : Any {
    val json = Json.encodeToString(this)
    return Json.decodeFromString(json)
}

// 사용
val original = SerializableUser(1L, "신짱구", mapOf("role" to "유치원생"))
val deepCopy = original.deepCopyWithSerialization()
```

---

## 4. 안드로이드에서의 사례

### 1. ViewModel에서의 상태 관리
```kotlin
data class UserState(
    val userList: List<User> = emptyList(),
    val selectedUser: User? = null
)

class UserViewModel : ViewModel() {
    private var currentState = UserState()
    
    fun addUser(user: User) {
        // 원본 상태 보호를 위해 깊은 복사 사용
        val newUserList = currentState.userList + user.deepCopy()
        currentState = currentState.copy(userList = newUserList)
    }
    
    fun updateUser(userId: Long, newName: String) {
        val updatedList = currentState.userList.map { user ->
            if (user.id == userId) {
                user.deepCopy().apply { name = newName }
            } else {
                user
            }
        }
        currentState = currentState.copy(userList = updatedList)
    }
}
```

### 2. RecyclerView Adapter에서 데이터 보호
```kotlin
class UserAdapter : RecyclerView.Adapter<UserViewHolder>() {
    private var users: List<User> = emptyList()
    
    fun updateUsers(newUsers: List<User>) {
        // 어댑터 내부에서 데이터 독립성 보장
        users = newUsers.map { it.deepCopy() }
        notifyDataSetChanged()
    }
    
    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
        val user = users[position]
        holder.bind(user)
        
        // 클릭 이벤트에서도 복사본 전달
        holder.itemView.setOnClickListener {
            onUserClick(user.deepCopy())
        }
    }
    
    private fun onUserClick(user: User) {
        // 원본 데이터에 영향을 주지 않는 복사본 사용
    }
}
```

### 3. Repository에서 데이터 관리
```kotlin
class UserRepository {
    private val userDao: UserDao = // ...
    
    suspend fun saveUser(user: User) {
        // 원본 데이터 보호를 위해 깊은 복사 후 저장
        val userCopy = user.deepCopy()
        userDao.insertUser(userCopy)
    }
    
    suspend fun getUser(id: Long): User? {
        val user = userDao.getUser(id)
        // 반환 시에도 복사본 제공
        return user?.deepCopy()
    }
    
    suspend fun updateUserName(id: Long, newName: String) {
        val user = userDao.getUser(id)?.deepCopy()
        user?.let {
            it.name = newName  // "신짱구" -> "신형만" 같은 업데이트
            userDao.updateUser(it)
        }
    }
}
```

---
