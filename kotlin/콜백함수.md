# 콜백함수

> 콜백함수는 프로그래밍에서 **"나중에 호출될 함수"** 를 의미합니다.  
> 마치 식당에서 주문을 받고 "음식이 준비되면 알려드릴게요"라고 하는 것처럼,  
> 특정 작업이 완료되거나 조건이 만족될 때 실행되도록 미리 등록해두는 함수입니다.  
> 
> Kotlin에서는 고차 함수와 람다 표현식을 통해 콜백을 간편하게 구현할 수 있으며,  
> Android 개발에서 비동기 작업, 이벤트 처리, API 호출 등 다양한 상황에서 활용됩니다.  
> 이 글에서는 콜백함수의 개념과 Android에서 어떻게 사용할 수 있는지 정리했습니다.

## 1. 콜백함수란?

콜백함수(Callback Function)는 **다른 함수의 인자로 전달되어, 특정 시점에 호출되는 함수**입니다.

### 기본 개념
- **Call**: 호출
- **Back**: 되돌아오다
- 즉, "나중에 다시 호출해주세요"라는 의미

### 콜백의 동작 원리
1. 함수 A가 함수 B를 인자로 받음
2. 함수 A가 특정 작업을 수행
3. 작업이 완료되거나 조건이 만족되면 함수 B를 호출
4. 함수 B가 실행됨

## 2. 콜백함수의 특징

### 2.1 비동기 처리
콜백은 주로 비동기 작업에서 결과를 처리할 때 사용됩니다.

```kotlin
// 비동기 작업 시뮬레이션
fun fetchDataFromServer(callback: (String) -> Unit) {
    // 백그라운드에서 데이터를 가져오는 작업
    Thread {
        Thread.sleep(2000) // 2초 대기 (네트워크 요청 시뮬레이션)
        val data = "서버에서 가져온 데이터"
        callback(data) // 작업 완료 후 콜백 호출
    }.start()
}

// 사용 예시
fetchDataFromServer { data ->
    println("받은 데이터: $data")
}
```

### 2.2 이벤트 처리
사용자 인터랙션이나 시스템 이벤트에 반응할 때 사용됩니다.

```kotlin
class Button {
    private var onClickListener: (() -> Unit)? = null
    
    fun setOnClickListener(listener: () -> Unit) {
        onClickListener = listener
    }
    
    fun click() {
        onClickListener?.invoke() // 클릭 시 콜백 실행
    }
}

// 사용 예시
val button = Button()
button.setOnClickListener {
    println("버튼이 클릭되었습니다!")
}
button.click() // "버튼이 클릭되었습니다!" 출력
```

### 2.3 결과 처리
작업의 성공/실패에 따라 다른 처리를 할 때 사용됩니다.

```kotlin
fun processData(
    data: String,
    onSuccess: (String) -> Unit,
    onError: (String) -> Unit
) {
    try {
        val result = data.uppercase()
        onSuccess(result) // 성공 시 콜백
    } catch (e: Exception) {
        onError(e.message ?: "알 수 없는 오류") // 실패 시 콜백
    }
}

// 사용 예시
processData(
    data = "hello world",
    onSuccess = { result -> println("성공: $result") },
    onError = { error -> println("오류: $error") }
)
```

## 3. Kotlin에서의 콜백 구현 방법

### 3.1 함수 타입을 사용한 콜백

```kotlin
// 단순한 콜백
fun performTask(callback: () -> Unit) {
    println("작업 시작")
    // ... 작업 수행 ...
    println("작업 완료")
    callback() // 콜백 호출
}

// 매개변수가 있는 콜백
fun calculateSum(a: Int, b: Int, callback: (Int) -> Unit) {
    val result = a + b
    callback(result)
}

// 사용 예시
performTask {
    println("콜백이 실행되었습니다!")
}

calculateSum(5, 3) { result ->
    println("계산 결과: $result")
}
```

### 3.2 nullable 콜백

```kotlin
class DataProcessor {
    private var onDataProcessed: ((String) -> Unit)? = null
    
    fun setOnDataProcessedListener(listener: (String) -> Unit) {
        onDataProcessed = listener
    }
    
    fun processData(data: String) {
        val processedData = data.trim().uppercase()
        onDataProcessed?.invoke(processedData)
    }
}

// 사용 예시
val processor = DataProcessor()
processor.setOnDataProcessedListener { processedData ->
    println("처리된 데이터: $processedData")
}
processor.processData("  hello world  ")
```

### 3.3 여러 개의 콜백

```kotlin
class NetworkManager {
    fun fetchUserData(
        userId: String,
        onSuccess: (User) -> Unit,
        onError: (String) -> Unit,
        onLoading: (Boolean) -> Unit
    ) {
        onLoading(true) // 로딩 시작
        
        // 네트워크 요청 시뮬레이션
        Thread {
            try {
                Thread.sleep(1000)
                val user = User(id = userId, name = "홍길동")
                onSuccess(user) // 성공 콜백
            } catch (e: Exception) {
                onError("네트워크 오류: ${e.message}") // 실패 콜백
            } finally {
                onLoading(false) // 로딩 종료
            }
        }.start()
    }
}

data class User(val id: String, val name: String)

// 사용 예시
val networkManager = NetworkManager()
networkManager.fetchUserData(
    userId = "123",
    onSuccess = { user -> println("사용자 정보: $user") },
    onError = { error -> println("오류: $error") },
    onLoading = { isLoading -> println("로딩 중: $isLoading") }
)
```

## 4. 콜백의 장단점

### 4.1 장점

1. **비동기 처리**: UI를 블로킹하지 않고 백그라운드 작업 수행
2. **유연성**: 다양한 상황에 맞는 처리가 가능
3. **재사용성**: 같은 콜백을 여러 곳에서 사용 가능
4. **이벤트 기반**: 사용자 인터랙션에 즉각 반응

### 4.2 단점

1. **콜백 지옥**: 콜백이 중첩되면 코드가 복잡해짐
2. **에러 처리**: 콜백 체인에서 에러 처리가 어려움
3. **디버깅**: 비동기 콜백의 실행 순서 추적이 어려움
4. **메모리 누수**: 콜백이 제대로 해제되지 않으면 메모리 누수 발생

```kotlin
// 콜백 지옥 예시
fetchUserData { user ->
    fetchUserPosts(user.id) { posts ->
        fetchPostComments(posts.first().id) { comments ->
            fetchCommentReplies(comments.first().id) { replies ->
                // 콜백이 계속 중첩됨...
            }
        }
    }
}
```

## 5. 대안: Coroutines와 Flow

### 5.1 Coroutines 사용

```kotlin
// 콜백 대신 suspend 함수 사용
suspend fun fetchUserData(userId: String): User {
    return withContext(Dispatchers.IO) {
        // 네트워크 요청
        delay(1000)
        User(id = userId, name = "홍길동")
    }
}

// 사용 예시
lifecycleScope.launch {
    try {
        val user = fetchUserData("123")
        println("사용자 정보: $user")
    } catch (e: Exception) {
        println("오류: ${e.message}")
    }
}
```

### 5.2 Flow 사용

```kotlin
fun fetchUserDataFlow(userId: String): Flow<User> = flow {
    emit(User(id = userId, name = "로딩 중..."))
    
    delay(1000)
    emit(User(id = userId, name = "홍길동"))
}

// 사용 예시
lifecycleScope.launch {
    fetchUserDataFlow("123")
        .catch { e -> println("오류: ${e.message}") }
        .collect { user ->
            println("사용자 정보: $user")
        }
}
```
