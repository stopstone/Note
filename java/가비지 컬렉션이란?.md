# 가비지 컬렉션이란?

> JVM에서 메모리 관리를 자동으로 수행하는 핵심 기능입니다.  
> 개발자가 명시적으로 메모리를 해제하지 않아도 되게 해주지만,  
> Stop-The-World 현상으로 인한 성능 이슈를 이해하고 최적화하는 것이 중요합니다.

## 1. 가비지 컬렉션이란?

### 1-1. 정의

**가비지 컬렉션(Garbage Collection, GC)**은 JVM에서 더 이상 사용되지 않는 객체를 자동으로 찾아서 메모리를 해제하는 프로세스입니다.

### 1-2. 왜 필요한가?

* **메모리 누수 방지**: 개발자가 수동으로 메모리를 해제하지 않아도 됨
* **프로그래밍 편의성**: C/C++처럼 `free()`, `delete` 같은 명시적 메모리 해제 불필요
* **안정성**: 잘못된 메모리 해제로 인한 버그 방지

## 2. JVM 메모리 구조

```
JVM Memory Structure
┌─────────────────────────────────────┐
│              JVM Heap               │
├─────────────────────────────────────┤
│  Young Generation (Eden + Survivor) │
│  ┌─────────┬─────────┬─────────┐   │
│  │  Eden   │  S0     │   S1    │   │
│  └─────────┴─────────┴─────────┘   │
├─────────────────────────────────────┤
│         Old Generation              │
│  ┌─────────────────────────────────┐ │
│  │        Tenured Space           │ │
│  └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

### 2-1. Young Generation (새로운 객체)

* **Eden**: 새로 생성된 객체가 처음 할당되는 곳
* **Survivor Space (S0, S1)**: Eden에서 살아남은 객체들이 이동하는 곳
* **Minor GC**: Young Generation에서 발생하는 GC

### 2-2. Old Generation (오래된 객체)

* **Tenured Space**: 오래 살아남은 객체들이 이동하는 곳
* **Major GC**: Old Generation에서 발생하는 GC (Full GC의 일부)

## 3. 가비지 컬렉션 과정

### 3-1. Mark & Sweep 알고리즘

```java
// 예시: 가비지 컬렉션 대상이 되는 객체들
public class GarbageCollectionExample {
    public static void main(String[] args) {
        // 1. 참조가 있는 객체 (GC 대상 아님)
        String aliveObject = "I'm alive!";
        
        // 2. 참조가 끊어진 객체 (GC 대상)
        String deadObject = "I'm dead!";
        deadObject = null; // 참조 해제
        
        // 3. 지역 변수 (메서드 종료 시 자동 해제)
        String localObject = "I'm local!";
        
        // 4. 순환 참조 (GC 대상)
        Node node1 = new Node();
        Node node2 = new Node();
        node1.next = node2;
        node2.next = node1;
        node1 = null;
        node2 = null;
    }
}

class Node {
    Node next;
}
```

### 3-2. GC 과정 단계

1. **Mark Phase**: 루트 객체부터 시작하여 도달 가능한 객체들을 마킹
2. **Sweep Phase**: 마킹되지 않은 객체들을 메모리에서 해제
3. **Compact Phase**: 메모리 단편화를 방지하기 위해 객체들을 재배치

## 4. 가비지 컬렉터 종류

### 4-1. Serial GC

* **특징**: 단일 스레드로 동작, Stop-The-World 발생
* **사용 시기**: 메모리가 작고 CPU 코어가 1개인 경우
* **JVM 옵션**: `-XX:+UseSerialGC`

### 4-2. Parallel GC (Throughput Collector)

* **특징**: 멀티스레드로 동작, 처리량(Throughput) 최적화
* **사용 시기**: CPU 코어가 여러 개이고 처리량이 중요한 경우
* **JVM 옵션**: `-XX:+UseParallelGC`

### 4-3. CMS GC (Concurrent Mark Sweep)

* **특징**: 애플리케이션과 동시에 실행, 응답 시간 최적화
* **단점**: 메모리 단편화 발생 가능
* **JVM 옵션**: `-XX:+UseConcMarkSweepGC`

### 4-4. G1 GC (Garbage First)

* **특징**: Java 9부터 기본 GC, 예측 가능한 일시정지 시간
* **장점**: 큰 힙에서도 일정한 응답 시간 보장
* **JVM 옵션**: `-XX:+UseG1GC`

### 4-5. ZGC (Z Garbage Collector)

* **특징**: Java 11부터 도입, 매우 낮은 일시정지 시간
* **장점**: 대용량 힙에서도 10ms 이하 일시정지
* **JVM 옵션**: `-XX:+UseZGC`

## 5. Stop-The-World란?

### 5-1. 정의

가비지 컬렉션이 실행되는 동안 애플리케이션의 모든 스레드가 일시적으로 정지되는 현상입니다.

### 5-2. 발생 원인

* **안전성**: GC 중에 객체 참조가 변경되면 안전하지 않음
* **일관성**: 메모리 상태의 일관성을 보장하기 위함

### 5-3. 최소화 방법

```java
// GC 부하를 줄이는 방법들
public class GCOptimizationExample {
    
    // 1. 객체 재사용
    private static final StringBuilder reusableBuilder = new StringBuilder();
    
    public static String buildString(List<String> items) {
        reusableBuilder.setLength(0); // 재사용
        for (String item : items) {
            reusableBuilder.append(item);
        }
        return reusableBuilder.toString();
    }
    
    // 2. 불필요한 객체 생성 방지
    public static void badExample() {
        for (int i = 0; i < 1000; i++) {
            String result = new String("Hello"); // 매번 새 객체 생성
        }
    }
    
    public static void goodExample() {
        String constant = "Hello"; // 상수 재사용
        for (int i = 0; i < 1000; i++) {
            String result = constant;
        }
    }
    
    // 3. 적절한 컬렉션 사용
    public static void collectionExample() {
        // 잘못된 예: 초기 용량 미지정
        List<String> badList = new ArrayList<>();
        
        // 올바른 예: 초기 용량 지정
        List<String> goodList = new ArrayList<>(1000);
    }
}
```

## 6. GC 모니터링 및 튜닝

### 6-1. GC 로그 분석

```bash
# GC 로그 활성화
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-XX:+PrintGCDateStamps
-Xloggc:gc.log
```

### 6-2. 주요 JVM 옵션

```bash
# 힙 크기 설정
-Xms2g          # 초기 힙 크기
-Xmx4g          # 최대 힙 크기

# Young Generation 크기
-Xmn1g          # Young Generation 크기
-XX:NewRatio=3  # Old:Young 비율

# GC 일시정지 시간 목표
-XX:MaxGCPauseMillis=200  # 최대 200ms
```

### 6-3. GC 성능 지표

* **Throughput**: 전체 시간 대비 GC 시간 비율
* **Latency**: GC 일시정지 시간
* **Footprint**: 메모리 사용량

## 7. 실제 문제 해결 사례

### 7-1. 메모리 누수 감지

```java
public class MemoryLeakExample {
    private static final List<Object> cache = new ArrayList<>();
    
    // 메모리 누수 발생 코드
    public static void addToCache(Object obj) {
        cache.add(obj); // 계속 쌓임, 제거되지 않음
    }
    
    // 해결 방법: WeakReference 사용
    private static final List<WeakReference<Object>> weakCache = new ArrayList<>();
    
    public static void addToWeakCache(Object obj) {
        weakCache.add(new WeakReference<>(obj));
    }
}
```

### 7-2. GC 튜닝 예제

```java
// 대용량 데이터 처리 시 GC 최적화
public class LargeDataProcessor {
    
    // 잘못된 예: 모든 데이터를 메모리에 로드
    public static void processAllData(List<String> allData) {
        List<String> processed = new ArrayList<>();
        for (String data : allData) {
            processed.add(process(data));
        }
    }
    
    // 올바른 예: 스트림 사용으로 메모리 효율성 증대
    public static void processDataStream(List<String> allData) {
        allData.stream()
               .map(LargeDataProcessor::process)
               .forEach(result -> saveResult(result));
    }
    
    private static String process(String data) {
        // 데이터 처리 로직
        return data.toUpperCase();
    }
    
    private static void saveResult(String result) {
        // 결과 저장 로직
    }
}
```

## 8. 면접에서 나올 수 있는 질문들

### 8-1. 기본 질문

* **Q**: 가비지 컬렉션이란 무엇인가요?
* **A**: JVM에서 더 이상 사용되지 않는 객체를 자동으로 찾아서 메모리를 해제하는 프로세스입니다.

* **Q**: Stop-The-World가 발생하는 이유는?
* **A**: GC 중에 객체 참조가 변경되면 안전하지 않기 때문에 모든 스레드를 일시정지시켜 일관성을 보장합니다.

### 8-2. 심화 질문

* **Q**: G1 GC와 CMS GC의 차이점은?
* **A**: G1 GC는 예측 가능한 일시정지 시간을 제공하고, CMS GC는 애플리케이션과 동시에 실행되어 응답 시간을 최적화합니다.

* **Q**: 메모리 누수를 어떻게 감지하나요?
* **A**: JProfiler, MAT(Memory Analyzer Tool) 등을 사용하여 힙 덤프를 분석하고, WeakReference를 적절히 활용합니다.
