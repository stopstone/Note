# 프리미티브 타입과 래퍼런스 타입

> Java와 Kotlin에서 데이터 타입을 이해하는 핵심 개념인 `프리미티브 타입(Primitive Type)`과 `래퍼런스 타입(Reference Type)`에 대해 정리합니다.
> 특히 Kotlin에서의 처리 방식과 JVM 최적화, 메모리 관리 측면을 중점적으로 다룹니다.

---

## 목표
- 프리미티브 타입에 대해 설명할 수 있다.
- 래퍼런스 타입에 대해 설명할 수 있다.
- Kotlin에서의 타입 처리 방식을 이해한다.
- 메모리 관리와 성능 최적화를 고려한 타입 선택을 할 수 있다.

---

## 1. Java 데이터 타입 분류

Java의 데이터 타입은 크게 두 가지로 분류됩니다:

```
Java Data Type 
├── Primitive Type (기본형)
│   ├── Boolean Type (boolean)
│   └── Numeric Type
│       ├── Integral Type
│       │   ├── Integer Type (byte, short, int, long)
│       │   └── Character Type (char)
│       └── Floating Point Type (float, double)
└── Reference Type (참조형)
    ├── Class Type
    ├── Interface Type
    ├── Array Type
    ├── Enum Type
    └── etc.
```

---

## 2. 프리미티브 타입 (Primitive Type)

### 2.1 특징
- **실제 값을 직접 메모리에 저장**하는 타입
- **스택(Stack) 메모리**에 저장됨
- **OS에 관계없이 일정한 크기**를 가짐
- **null 값을 가질 수 없음** (비객체 타입)
- **메모리 접근이 빠름** (성능 우수)
- **총 8가지 타입**이 미리 정의되어 제공됨

### 2.2 프리미티브 타입 종류

#### boolean
```java
boolean flag = true;  // 기본값: false
```
- **크기**: 1byte (실제로는 1bit면 충분하지만 최소 단위가 1byte)
- **용도**: 논리값 저장 (yes/no, on/off)
- **값**: true, false

#### byte
```java
byte b = 127;  // 범위: -128 ~ 127
```
- **크기**: 1byte
- **용도**: 이진 데이터 처리, 작은 정수값

#### short
```java
short s = 32767;  // 범위: -32,768 ~ 32,767
```
- **크기**: 2byte
- **용도**: C언어 호환성 (실제로는 거의 사용하지 않음)

#### int
```java
int number = 1000000;  // 범위: -2^31 ~ 2^31-1
```
- **크기**: 4byte
- **용도**: 정수 연산의 기본 타입
- **특징**: byte, short 연산 결과는 int로 변환됨

#### long
```java
long bigNumber = 9223372036854775807L;  // L 접미사 필수
```
- **크기**: 8byte
- **용도**: 큰 수치 데이터 (은행, 우주 관련 프로그램)
- **주의**: int 범위를 넘는 값은 반드시 L 접미사 필요

#### float, double
```java
float f = 3.14f;      // F 접미사 필수
double d = 3.14159;   // 기본 실수 타입
```
- **저장 방식**: 부동소수점 방식 (가수 + 지수)
- **정밀도**: double이 float보다 정밀함
- **기본 타입**: double (float 사용 시 F 접미사 필요)

#### char
```java
char c = 'A';  // 유니코드 문자
```
- **크기**: 2byte
- **용도**: 유니코드 문자 저장

---

## 3. 래퍼런스 타입 (Reference Type)

### 3.1 특징
- **객체의 메모리 주소(참조값)를 저장**하는 타입
- **Heap 메모리**에 객체 생성, **Stack**에 참조값 저장
- **null 값을 가질 수 있음**
- **Garbage Collector**가 메모리 관리
- **런타임 에러** 발생 가능 (NullPointerException 등)

### 3.2 래퍼런스 타입 종류

#### Class Type
```java
String str = "Hello";
Integer num = 100;
```

#### Interface Type
```java
List<String> list = new ArrayList<>();
```

#### Array Type
```java
int[] numbers = {1, 2, 3, 4, 5};
String[] names = new String[10];
```

#### Enum Type
```java
enum Color { RED, GREEN, BLUE }
Color myColor = Color.RED;
```

### 3.3 String 클래스의 특별함
```java
String str1 = "Hello";
String str2 = new String("Hello");

// 비교 시 주의사항
System.out.println(str1 == str2);        // false (참조값 비교)
System.out.println(str1.equals(str2));   // true (내용 비교)
```

**특징**:
- 참조형이지만 기본형처럼 사용
- **불변(Immutable) 객체**
- 메서드 호출 시 새로운 객체 생성
- 비교 시 `.equals()` 사용 권장

---

## 4. Kotlin에서의 타입 처리

### 4.1 Kotlin의 타입 시스템
```kotlin
val a: Int = 10           // nullable이 아니면 primitive로 최적화
val b: Int? = 10          // nullable이면 객체로 박싱
val c: String = "Hello"   // 항상 참조형
```

### 4.2 박싱(Boxing)과 언박싱(Unboxing)
```kotlin
// 박싱: primitive → wrapper object
val nullableInt: Int? = 42  // Integer 객체로 박싱

// 언박싱: wrapper object → primitive
val nonNullInt: Int = nullableInt!!  // primitive로 언박싱
```

### 4.3 Kotlin에서 프리미티브 타입이 없다는 말의 진실
- **언어 설계 차원**: 모든 타입이 객체처럼 보임
- **JVM 실행 차원**: nullable이 아니면 primitive로 최적화
- **개발자 관점**: primitive 타입이 보이지 않을 뿐, 내부적으로는 존재

---

## 5. 메모리 관리와 성능

### 5.1 메모리 구조
```
Stack Memory (프리미티브 타입)
├── int a = 10
├── boolean flag = true
└── double pi = 3.14

Heap Memory (래퍼런스 타입)
├── String str = "Hello" → [H][e][l][l][o]
├── Integer num = 100 → [100]
└── Array arr = {1,2,3} → [1][2][3]
```

### 5.2 성능 비교
| 측면 | 프리미티브 타입 | 래퍼런스 타입 |
|------|----------------|---------------|
| 메모리 접근 | 빠름 (직접 접근) | 느림 (간접 접근) |
| 메모리 사용량 | 적음 | 많음 (객체 오버헤드) |
| GC 부담 | 없음 | 있음 |
| null 안전성 | 보장됨 | 런타임 에러 가능 |
