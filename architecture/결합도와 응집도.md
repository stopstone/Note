# 결합도와 응집도

> **결합도(Coupling)** 와 **응집도(Cohesion)** 는 소프트웨어 설계의 품질을 평가하는 지표입니다.  
> 좋은 설계는 **낮은 결합도(loose coupling)** 와 **높은 응집도(high cohesion)** 를 가져야 하며,  
> 이는 SOLID 원칙과 클린 아키텍처의 기반이 되는 개념입니다.

---

## 결합도와 응집도란?

### 결합도 (Coupling)
- **정의**: 모듈 간의 의존성 정도를 나타내는 지표
- **목표**: 낮은 결합도 (Loose Coupling)
- **의미**: 한 모듈의 변경이 다른 모듈에 미치는 영향이 적을수록 좋음

### 응집도 (Cohesion)
- **정의**: 하나의 모듈 내부 요소들이 얼마나 관련되어 있는지를 나타내는 지표
- **목표**: 높은 응집도 (High Cohesion)
- **의미**: 모듈 내부의 기능들이 하나의 목적을 위해 얼마나 잘 결합되어 있는지

> **좋은 설계의 원칙**: "낮은 결합도, 높은 응집도"  
> 이는 모듈이 독립적이면서도 내부적으로는 강하게 결합되어 있어야 한다는 의미입니다.

---

## 1. 결합도의 종류 (낮은 순서대로)

### 1.1 데이터 결합도 (Data Coupling)
```kotlin
// 가장 이상적인 결합도 - 데이터만 주고받음
class UserService(private val userRepository: UserRepository) {
    fun createUser(userData: UserData): User {
        return userRepository.save(userData)
    }
}

class UserRepository {
    fun save(userData: UserData): User {
        // 데이터베이스 저장 로직
        return User(userData.name, userData.email)
    }
}
```

### 1.2 스탬프 결합도 (Stamp Coupling)
```kotlin
// 객체 전체를 전달하지만 필요한 일부만 사용
class OrderService {
    fun processOrder(order: Order) {
        val orderId = order.id  // Order 객체에서 id만 사용
        val totalAmount = order.calculateTotal()  // total만 사용
        // 나머지 Order 정보는 사용하지 않음
    }
}
```

### 1.3 제어 결합도 (Control Coupling)
```kotlin
// 제어 정보를 통해 다른 모듈의 동작을 결정
class PaymentProcessor {
    fun processPayment(amount: Double, paymentType: PaymentType) {
        when (paymentType) {
            PaymentType.CREDIT_CARD -> processCreditCard(amount)
            PaymentType.BANK_TRANSFER -> processBankTransfer(amount)
            PaymentType.CASH -> processCash(amount)
        }
    }
}
```

### 1.4 외부 결합도 (External Coupling)
```kotlin
// 외부 환경에 의존
class DatabaseConfig {
    companion object {
        const val DATABASE_URL = "jdbc:mysql://localhost:3306/mydb"
        const val USERNAME = "admin"
        const val PASSWORD = "password"
    }
}

class UserRepository {
    fun connect() {
        // 외부 설정에 직접 의존
        val connection = DriverManager.getConnection(
            DatabaseConfig.DATABASE_URL,
            DatabaseConfig.USERNAME,
            DatabaseConfig.PASSWORD
        )
    }
}
```

### 1.5 공통 결합도 (Common Coupling)
```kotlin
// 전역 변수나 공통 데이터를 통해 결합
object GlobalConfig {
    var currentUser: User? = null
    var isLoggedIn: Boolean = false
}

class UserService {
    fun login(user: User) {
        GlobalConfig.currentUser = user  // 전역 변수 사용
        GlobalConfig.isLoggedIn = true
    }
}

class OrderService {
    fun createOrder(): Order? {
        if (!GlobalConfig.isLoggedIn) {  // 전역 변수 의존
            return null
        }
        return Order(GlobalConfig.currentUser!!)
    }
}
```

### 1.6 내용 결합도 (Content Coupling)
```kotlin
// 가장 나쁜 결합도 - 다른 모듈의 내부 구현에 직접 접근
class UserService {
    private val userRepository = UserRepository()
    
    fun updateUser(userId: Long, newName: String) {
        // UserRepository의 private 필드에 직접 접근 (위반!)
        userRepository.users.find { it.id == userId }?.name = newName
    }
}
```

---

## 2. 응집도의 종류 (높은 순서대로)

### 2.1 기능적 응집도 (Functional Cohesion)
```kotlin
// 가장 이상적인 응집도 - 하나의 기능을 수행
class PasswordValidator {
    fun validatePassword(password: String): ValidationResult {
        val hasMinLength = password.length >= 8
        val hasUpperCase = password.any { it.isUpperCase() }
        val hasLowerCase = password.any { it.isLowerCase() }
        val hasDigit = password.any { it.isDigit() }
        val hasSpecialChar = password.any { !it.isLetterOrDigit() }
        
        return ValidationResult(
            isValid = hasMinLength && hasUpperCase && hasLowerCase && hasDigit && hasSpecialChar,
            errors = buildErrorList(hasMinLength, hasUpperCase, hasLowerCase, hasDigit, hasSpecialChar)
        )
    }
    
    private fun buildErrorList(vararg conditions: Boolean): List<String> {
        val errors = mutableListOf<String>()
        if (!conditions[0]) errors.add("최소 8자 이상이어야 합니다")
        if (!conditions[1]) errors.add("대문자를 포함해야 합니다")
        if (!conditions[2]) errors.add("소문자를 포함해야 합니다")
        if (!conditions[3]) errors.add("숫자를 포함해야 합니다")
        if (!conditions[4]) errors.add("특수문자를 포함해야 합니다")
        return errors
    }
}
```

### 2.2 순차적 응집도 (Sequential Cohesion)
```kotlin
// 순차적으로 실행되는 관련 기능들
class OrderProcessor {
    fun processOrder(order: Order): OrderResult {
        val validatedOrder = validateOrder(order)
        val paymentResult = processPayment(validatedOrder)
        val inventoryResult = updateInventory(validatedOrder)
        val shippingResult = createShipping(validatedOrder)
        
        return OrderResult(paymentResult, inventoryResult, shippingResult)
    }
    
    private fun validateOrder(order: Order): Order { /* 검증 로직 */ }
    private fun processPayment(order: Order): PaymentResult { /* 결제 처리 */ }
    private fun updateInventory(order: Order): InventoryResult { /* 재고 업데이트 */ }
    private fun createShipping(order: Order): ShippingResult { /* 배송 생성 */ }
}
```

### 2.3 통신적 응집도 (Communicational Cohesion)
```kotlin
// 같은 데이터를 다루는 기능들
class UserDataManager {
    private val userRepository = UserRepository()
    
    fun getUserById(id: Long): User? {
        return userRepository.findById(id)
    }
    
    fun updateUser(user: User) {
        userRepository.update(user)
    }
    
    fun deleteUser(id: Long) {
        userRepository.deleteById(id)
    }
    
    fun getAllUsers(): List<User> {
        return userRepository.findAll()
    }
}
```

### 2.4 절차적 응집도 (Procedural Cohesion)
```kotlin
// 시간적 순서에 따라 실행되는 기능들
class UserRegistrationService {
    fun registerUser(userData: UserRegistrationData): RegistrationResult {
        validateUserData(userData)
        checkDuplicateEmail(userData.email)
        val hashedPassword = hashPassword(userData.password)
        val user = createUser(userData, hashedPassword)
        sendWelcomeEmail(user.email)
        logRegistration(user.id)
        
        return RegistrationResult.Success(user)
    }
    
    private fun validateUserData(data: UserRegistrationData) { /* 검증 */ }
    private fun checkDuplicateEmail(email: String) { /* 중복 확인 */ }
    private fun hashPassword(password: String): String { /* 비밀번호 해시 */ }
    private fun createUser(data: UserRegistrationData, hashedPassword: String): User { /* 사용자 생성 */ }
    private fun sendWelcomeEmail(email: String) { /* 환영 이메일 */ }
    private fun logRegistration(userId: Long) { /* 로그 기록 */ }
}
```

### 2.5 시간적 응집도 (Temporal Cohesion)
```kotlin
// 특정 시점에 실행되는 기능들
class SystemInitializer {
    fun initializeSystem() {
        initializeDatabase()
        initializeCache()
        initializeLogging()
        initializeSecurity()
        initializeMonitoring()
    }
    
    private fun initializeDatabase() { /* 데이터베이스 초기화 */ }
    private fun initializeCache() { /* 캐시 초기화 */ }
    private fun initializeLogging() { /* 로깅 초기화 */ }
    private fun initializeSecurity() { /* 보안 초기화 */ }
    private fun initializeMonitoring() { /* 모니터링 초기화 */ }
}
```

### 2.6 논리적 응집도 (Logical Cohesion)
```kotlin
// 논리적으로 관련된 기능들 (개선 필요)
class DataProcessor {
    fun processData(data: Any, operation: String) {
        when (operation) {
            "sort" -> sortData(data)
            "filter" -> filterData(data)
            "transform" -> transformData(data)
            "validate" -> validateData(data)
            "export" -> exportData(data)
        }
    }
    
    private fun sortData(data: Any) { /* 정렬 */ }
    private fun filterData(data: Any) { /* 필터링 */ }
    private fun transformData(data: Any) { /* 변환 */ }
    private fun validateData(data: Any) { /* 검증 */ }
    private fun exportData(data: Any) { /* 내보내기 */ }
}
```

### 2.7 우연적 응집도 (Coincidental Cohesion)
```kotlin
// 관련 없는 기능들이 모여있음 (가장 나쁜 응집도)
class UtilityClass {
    fun calculateTax(income: Double): Double { /* 세금 계산 */ }
    fun sendEmail(to: String, subject: String, body: String) { /* 이메일 전송 */ }
    fun validatePhoneNumber(phone: String): Boolean { /* 전화번호 검증 */ }
    fun generateRandomPassword(): String { /* 랜덤 비밀번호 생성 */ }
    fun formatCurrency(amount: Double): String { /* 통화 포맷팅 */ }
}
```

---

## 3. 안드로이드에서의 활용

### 3.1 높은 결합도 (나쁜 예시)
```kotlin
// MainActivity가 모든 것을 직접 처리 (높은 결합도)
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    private val retrofit = Retrofit.Builder()
        .baseUrl("https://api.example.com/")
        .addConverterFactory(GsonConverterFactory.create())
        .build()
    private val apiService = retrofit.create(ApiService::class.java)
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        loadUserData()
    }
    
    private fun loadUserData() {
        lifecycleScope.launch {
            try {
                val response = apiService.getUserData()
                binding.textView.text = response.name
                binding.emailView.text = response.email
                
                // SharedPreferences에 직접 저장
                getSharedPreferences("user_prefs", Context.MODE_PRIVATE)
                    .edit()
                    .putString("user_name", response.name)
                    .putString("user_email", response.email)
                    .apply()
                    
            } catch (e: Exception) {
                Toast.makeText(this@MainActivity, "오류: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

### 3.2 낮은 결합도 (좋은 예시)
```kotlin
// 의존성 주입과 Repository 패턴 사용
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    private val viewModel: MainViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        observeUserData()
        viewModel.loadUserData()
    }
    
    private fun observeUserData() {
        viewModel.userData.observe(this) { userData ->
            binding.textView.text = userData.name
            binding.emailView.text = userData.email
        }
        
        viewModel.error.observe(this) { error ->
            Toast.makeText(this, error, Toast.LENGTH_SHORT).show()
        }
    }
}

@HiltViewModel
class MainViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _userData = MutableLiveData<UserData>()
    val userData: LiveData<UserData> = _userData
    
    private val _error = MutableLiveData<String>()
    val error: LiveData<String> = _error
    
    fun loadUserData() {
        viewModelScope.launch {
            try {
                val data = userRepository.getUserData()
                _userData.value = data
            } catch (e: Exception) {
                _error.value = e.message
            }
        }
    }
}

@Singleton
class UserRepository @Inject constructor(
    private val apiService: ApiService,
    private val userPreferences: UserPreferences
) {
    suspend fun getUserData(): UserData {
        val userData = apiService.getUserData()
        userPreferences.saveUserData(userData)
        return userData
    }
}
```

### 3.3 높은 응집도 (좋은 예시)
```kotlin
// 사용자 인증 관련 기능들이 하나의 클래스에 모여있음
class AuthenticationManager @Inject constructor(
    private val authRepository: AuthRepository,
    private val biometricManager: BiometricManager,
    private val tokenManager: TokenManager
) {
    
    suspend fun login(email: String, password: String): AuthResult {
        return try {
            val credentials = validateCredentials(email, password)
            val authResponse = authRepository.login(credentials)
            val tokens = processAuthResponse(authResponse)
            tokenManager.saveTokens(tokens)
            
            AuthResult.Success(tokens.userId)
        } catch (e: InvalidCredentialsException) {
            AuthResult.Error("잘못된 이메일 또는 비밀번호입니다")
        } catch (e: NetworkException) {
            AuthResult.Error("네트워크 오류가 발생했습니다")
        } catch (e: Exception) {
            AuthResult.Error("로그인 중 오류가 발생했습니다")
        }
    }
    
    suspend fun loginWithBiometric(): AuthResult {
        return try {
            if (!biometricManager.isBiometricAvailable()) {
                return AuthResult.Error("생체 인증을 사용할 수 없습니다")
            }
            
            val biometricResult = biometricManager.authenticate()
            if (biometricResult.isSuccess) {
                val storedTokens = tokenManager.getStoredTokens()
                if (storedTokens != null) {
                    AuthResult.Success(storedTokens.userId)
                } else {
                    AuthResult.Error("저장된 로그인 정보가 없습니다")
                }
            } else {
                AuthResult.Error("생체 인증에 실패했습니다")
            }
        } catch (e: Exception) {
            AuthResult.Error("생체 인증 중 오류가 발생했습니다")
        }
    }
    
    fun logout() {
        tokenManager.clearTokens()
        authRepository.logout()
    }
    
    fun isLoggedIn(): Boolean {
        return tokenManager.hasValidTokens()
    }
    
    private fun validateCredentials(email: String, password: String): LoginCredentials {
        if (email.isBlank() || password.isBlank()) {
            throw InvalidCredentialsException("이메일과 비밀번호를 입력해주세요")
        }
        if (!android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
            throw InvalidCredentialsException("올바른 이메일 형식이 아닙니다")
        }
        return LoginCredentials(email, password)
    }
    
    private fun processAuthResponse(response: AuthResponse): AuthTokens {
        return AuthTokens(
            accessToken = response.accessToken,
            refreshToken = response.refreshToken,
            userId = response.userId
        )
    }
}
```

### 3.4 낮은 응집도 (나쁜 예시)
```kotlin
// 관련 없는 기능들이 하나의 클래스에 모여있음
class UtilityManager {
    // 사용자 관련
    fun validateEmail(email: String): Boolean { /* 이메일 검증 */ }
    fun hashPassword(password: String): String { /* 비밀번호 해시 */ }
    
    // UI 관련
    fun showLoadingDialog(context: Context) { /* 로딩 다이얼로그 */ }
    fun hideLoadingDialog() { /* 로딩 다이얼로그 숨김 */ }
    fun showErrorToast(context: Context, message: String) { /* 에러 토스트 */ }
    
    // 네트워크 관련
    fun isNetworkAvailable(context: Context): Boolean { /* 네트워크 확인 */ }
    fun getNetworkType(context: Context): String { /* 네트워크 타입 */ }
    
    // 파일 관련
    fun saveFileToInternalStorage(context: Context, fileName: String, content: String) { /* 파일 저장 */ }
    fun readFileFromInternalStorage(context: Context, fileName: String): String? { /* 파일 읽기 */ }
    
    // 날짜 관련
    fun formatDate(date: Date): String { /* 날짜 포맷팅 */ }
    fun parseDate(dateString: String): Date? { /* 날짜 파싱 */ }
    
    // 암호화 관련
    fun encryptString(input: String): String { /* 문자열 암호화 */ }
    fun decryptString(encrypted: String): String { /* 문자열 복호화 */ }
}
```

---

## 4. 결합도와 응집도 개선 방법

### 4.1 의존성 주입 활용
```kotlin
// 의존성 주입을 통한 결합도 감소
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideApiService(): ApiService {
        return Retrofit.Builder()
            .baseUrl(BuildConfig.API_BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(ApiService::class.java)
    }
    
    @Provides
    @Singleton
    fun provideUserRepository(
        apiService: ApiService,
        userPreferences: UserPreferences
    ): UserRepository {
        return UserRepositoryImpl(apiService, userPreferences)
    }
    
    @Provides
    @Singleton
    fun provideUserPreferences(@ApplicationContext context: Context): UserPreferences {
        return UserPreferencesImpl(context)
    }
}
```

### 4.2 인터페이스 분리
```kotlin
// 인터페이스를 통한 결합도 감소
interface UserRepository {
    suspend fun getUserById(id: Long): User?
    suspend fun saveUser(user: User): User
    suspend fun deleteUser(id: Long): Boolean
}

interface UserPreferences {
    suspend fun saveUserData(userData: UserData)
    suspend fun getUserData(): UserData?
    suspend fun clearUserData()
}

// 구현체는 인터페이스에만 의존
class UserRepositoryImpl @Inject constructor(
    private val apiService: ApiService,
    private val userPreferences: UserPreferences
) : UserRepository {
    // 구현 내용
}
```

### 4.3 단일 책임 원칙 적용
```kotlin
// 각 클래스가 하나의 책임만 가지도록 분리
class EmailValidator {
    fun validate(email: String): ValidationResult {
        // 이메일 검증만 담당
    }
}

class PasswordValidator {
    fun validate(password: String): ValidationResult {
        // 비밀번호 검증만 담당
    }
}

class UserDataValidator @Inject constructor(
    private val emailValidator: EmailValidator,
    private val passwordValidator: PasswordValidator
) {
    fun validateUserData(userData: UserRegistrationData): ValidationResult {
        // 사용자 데이터 검증 조합
    }
}
```

---

## 5. 결합도와 응집도 측정 방법

### 5.1 정적 분석 도구 활용
```kotlin
// Android Studio의 Analyze > Inspect Code 활용
// 또는 SonarQube, Detekt 등의 도구 사용

// 예시: 순환 의존성 감지
class UserService(private val orderService: OrderService) {
    fun getUserWithOrders(userId: Long): UserWithOrders {
        val user = getUserById(userId)
        val orders = orderService.getOrdersByUserId(userId)  // 순환 의존성 가능성
        return UserWithOrders(user, orders)
    }
}

class OrderService(private val userService: UserService) {  // 순환 의존성!
    fun getOrdersByUserId(userId: Long): List<Order> {
        val user = userService.getUserById(userId)  // 순환 의존성
        return getOrdersForUser(user)
    }
}
```

### 5.2 테스트를 통한 결합도 확인
```kotlin
// 단위 테스트에서 Mock 객체 사용이 어려우면 높은 결합도
class UserServiceTest {
    
    @Test
    fun `사용자 생성 테스트`() {
        // Mock 객체 사용이 어려우면 결합도가 높음
        val userService = UserService(
            UserRepository(),
            EmailService(),
            NotificationService(),
            AuditService()
        )
        
        val result = userService.createUser(UserData("test@example.com", "password"))
        
        assertTrue(result.isSuccess)
    }
}

// 개선된 버전 - 의존성 주입으로 테스트 용이성 향상
class UserServiceTest {
    
    @Mock
    private lateinit var userRepository: UserRepository
    
    @Mock
    private lateinit var emailService: EmailService
    
    @InjectMocks
    private lateinit var userService: UserService
    
    @Test
    fun `사용자 생성 테스트`() {
        // given
        val userData = UserData("test@example.com", "password")
        val expectedUser = User(1L, "test@example.com")
        
        `when`(userRepository.save(any())).thenReturn(expectedUser)
        `when`(emailService.sendWelcomeEmail(any())).thenReturn(Unit)
        
        // when
        val result = userService.createUser(userData)
        
        // then
        assertTrue(result.isSuccess)
        verify(userRepository).save(any())
        verify(emailService).sendWelcomeEmail(any())
    }
}
```

---

## 6. 실무에서의 적용 팁

### 6.1 점진적 개선
```kotlin
// 1단계: 큰 클래스를 작은 클래스로 분리
class UserManager {
    // 사용자 인증 관련
    fun authenticate(email: String, password: String): AuthResult { /* ... */ }
    fun logout() { /* ... */ }
    
    // 사용자 정보 관련
    fun updateProfile(userId: Long, profile: UserProfile) { /* ... */ }
    fun getProfile(userId: Long): UserProfile? { /* ... */ }
    
    // 사용자 설정 관련
    fun updateSettings(userId: Long, settings: UserSettings) { /* ... */ }
    fun getSettings(userId: Long): UserSettings? { /* ... */ }
}

// 2단계: 책임별로 분리
class AuthenticationManager {
    fun authenticate(email: String, password: String): AuthResult { /* ... */ }
    fun logout() { /* ... */ }
}

class ProfileManager {
    fun updateProfile(userId: Long, profile: UserProfile) { /* ... */ }
    fun getProfile(userId: Long): UserProfile? { /* ... */ }
}

class SettingsManager {
    fun updateSettings(userId: Long, settings: UserSettings) { /* ... */ }
    fun getSettings(userId: Long): UserSettings? { /* ... */ }
}
```

### 6.2 의존성 방향 제어
```kotlin
// 의존성 방향을 한 방향으로만 흐르도록 설계
// Domain Layer (가장 안쪽)
interface UserRepository {
    suspend fun getUserById(id: Long): User?
    suspend fun saveUser(user: User): User
}

// Data Layer (Domain에 의존)
class UserRepositoryImpl @Inject constructor(
    private val apiService: ApiService,
    private val userDao: UserDao
) : UserRepository {
    // 구현
}

// Presentation Layer (Domain에 의존)
class UserViewModel @Inject constructor(
    private val userRepository: UserRepository  // 인터페이스에만 의존
) : ViewModel() {
    // 구현
}
```

### 6.3 모듈 경계 명확화
```kotlin
// 각 모듈의 경계를 명확히 정의
@Module
@InstallIn(SingletonComponent::class)
object UserModule {
    
    @Provides
    @Singleton
    fun provideUserRepository(
        apiService: ApiService,
        userDao: UserDao
    ): UserRepository {
        return UserRepositoryImpl(apiService, userDao)
    }
}

@Module
@InstallIn(SingletonComponent::class)
object OrderModule {
    
    @Provides
    @Singleton
    fun provideOrderRepository(
        apiService: ApiService,
        orderDao: OrderDao
    ): OrderRepository {
        return OrderRepositoryImpl(apiService, orderDao)
    }
}
```

---

## 7. 면접에서 자주 나오는 질문

### Q1: 결합도와 응집도의 차이점은?
**A**: 결합도는 모듈 간의 의존성 정도를 나타내며, 응집도는 모듈 내부 요소들의 관련성을 나타냅니다. 좋은 설계는 낮은 결합도와 높은 응집도를 가져야 합니다.

### Q2: 결합도를 낮추는 방법은?
**A**: 의존성 주입, 인터페이스 활용, 이벤트 기반 통신, 모듈화 등을 통해 결합도를 낮출 수 있습니다.

### Q3: 응집도를 높이는 방법은?
**A**: 단일 책임 원칙을 적용하여 관련된 기능들을 하나의 클래스에 모으고, 관련 없는 기능들은 분리합니다.

### Q4: 실제 프로젝트에서 어떻게 적용했나요?
**A**: Repository 패턴과 의존성 주입을 사용하여 데이터 계층과 비즈니스 계층의 결합도를 낮추고, 각 클래스가 하나의 책임만 가지도록 설계했습니다.

---
