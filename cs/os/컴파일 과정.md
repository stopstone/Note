# 컴파일 과정

> 작성한 소스 코드가 어떻게 컴파일되어 실행 가능한 바이너리 파일이 되는지 단계별로 알아보겠습니다.

---

## 1. 컴파일 과정의 4단계

### 1.1 전체 흐름

```kotlin
/**
 * 컴파일 과정
 * 
 * 소스 코드(.kt, .java, .c 등)
 *    ↓
 * [1] 전처리(Preprocessing)
 *    ↓
 * [2] 컴파일(Compilation)
 *    ↓
 * [3] 어셈블(Assembly)
 *    ↓
 * [4] 링킹(Linking)
 *    ↓
 * 실행 파일(.exe, .apk, .dex 등)
 */
```

---

## 2. 각 단계 상세 설명

### 2.1 전처리 (Preprocessing)

**역할**: 소스 코드를 컴파일하기 전에 전처리기가 특정 지시문을 처리하는 단계

**주요 작업**:
- `#include`, `#define` 등의 전처리기 지시문 처리
- 매크로 확장
- 주석 제거
- 조건부 컴파일 처리

```c
// 전처리 전
#define MAX_SIZE 100
#include <stdio.h>

int main() {
    int arr[MAX_SIZE];  // 매크로 사용
    return 0;
}

// 전처리 후
// stdio.h의 내용이 삽입됨
int main() {
    int arr[100];  // MAX_SIZE가 100으로 치환됨
    return 0;
}
```

**Kotlin/Android에서**:
- Kotlin은 전처리기를 사용하지 않음
- 대신 컴파일 타임에 어노테이션 프로세싱을 사용

---

### 2.2 컴파일 (Compilation)

**역할**: 전처리된 소스 코드를 어셈블리어로 변환하는 단계

**주요 작업**:
- 문법 검사 (Syntax Analysis)
- 의미 분석 (Semantic Analysis)
- 타입 검사 (Type Checking)
- 중간 코드 생성 (Intermediate Code)
- 최적화 (Optimization)
- 어셈블리 코드 생성

```kotlin
// 소스 코드 (Kotlin)
fun calculateSum(a: Int, b: Int): Int {
    return a + b
}

// 컴파일 후 JVM 바이트코드 (개념적 표현)
// 실제로는 바이너리 형태
public static calculateSum(II)I
    ILOAD 0    // 첫 번째 파라미터 로드
    ILOAD 1    // 두 번째 파라미터 로드
    IADD       // 더하기 연산
    IRETURN    // 결과 반환
```

---

### 2.3 어셈블 (Assembly)

**역할**: 어셈블리어를 기계어(오브젝트 파일)로 변환하는 단계

**주요 작업**:
- 어셈블리 명령어를 기계어로 번역
- 오브젝트 파일(.o, .obj) 생성
- 심볼 테이블 생성 (함수명, 변수명 등의 주소 정보)

```assembly
; 어셈블리 코드
MOV EAX, [a]    ; a를 EAX 레지스터로 이동
ADD EAX, [b]    ; b를 EAX에 더함
RET             ; 반환

; 어셈블 후 기계어 (16진수 표현)
8B 45 F8        ; MOV EAX, [a]
03 45 FC        ; ADD EAX, [b]  
C3              ; RET
```

**Android에서**:
```kotlin
// Kotlin 코드 → JVM 바이트코드(.class) 생성
kotlinc MainActivity.kt -d output/

// JVM 바이트코드 → DEX 파일(.dex) 변환
d8 --release --output . MainActivity.class
```

---

### 2.4 링킹 (Linking)

**역할**: 여러 오브젝트 파일과 라이브러리를 연결하여 최종 실행 파일을 만드는 단계

**주요 작업**:
- 심볼 해석(Symbol Resolution): 함수 호출, 변수 참조 등의 주소 연결
- 재배치(Relocation): 코드와 데이터를 메모리 주소에 배치
- 라이브러리 연결: 정적 라이브러리(.a, .lib) 또는 동적 라이브러리(.so, .dll) 연결

```kotlin
// File1.kt
fun greet(name: String) {
    println("Hello, $name")
}

// File2.kt (메인 파일)
fun main() {
    greet("Android")  // File1의 함수 호출
}

/**
 * 링킹 과정:
 * 1. File1.class와 File2.class 생성 (컴파일/어셈블)
 * 2. File2에서 greet() 함수 참조를 File1의 실제 주소로 연결 (링킹)
 * 3. 최종 실행 파일 생성
 */
```

**링킹 종류**:

| 구분 | 정적 링킹 (Static Linking) | 동적 링킹 (Dynamic Linking) |
|------|--------------------------|---------------------------|
| **시점** | 컴파일 타임 | 런타임 |
| **라이브러리** | 실행 파일에 포함됨 | 별도의 파일로 존재 (.so, .dll) |
| **파일 크기** | 크다 | 작다 |
| **메모리** | 각 프로그램이 복사본 보유 | 여러 프로그램이 공유 |
| **예시** | `.a`, `.lib` | `.so`, `.dll` |

---

## 3. Android 컴파일 과정

### 3.1 Kotlin/Java → DEX 변환

```kotlin
/**
 * Android 컴파일 프로세스
 * 
 * [1] 소스 코드 컴파일
 *     Kotlin/Java → JVM 바이트코드(.class)
 *     
 * [2] DEX 변환
 *     .class → DEX 파일(.dex)
 *     - D8: 디버그 빌드
 *     - R8: 릴리스 빌드 (난독화 + 최적화)
 *     
 * [3] 리소스 컴파일
 *     XML, 이미지 등 → 컴파일된 리소스
 *     AAPT2 사용
 *     
 * [4] 패키징
 *     DEX + 리소스 + 라이브러리 → APK/AAB
 *     
 * [5] 서명
 *     디지털 서명 추가 (APK Signer)
 */
```
