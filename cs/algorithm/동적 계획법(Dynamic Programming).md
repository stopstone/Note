# 동적 계획법(Dynamic Programming)

> 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법입니다.  
> 흔히 말하는 DP가 바로 '동적 계획법'입니다.   
> 한 가지 문제에 대해서, 단 한 번만 풀도록 만들어주는 알고리즘입니다.  
> 즉, 똑같은 연산을 반복하지 않도록 만들어줍니다.  
> 실행 시간을 줄이기 위해 많이 이용되는 수학적 접근 방식의 알고리즘이라고 할 수 있습니다.  

---

## 2. 언제 사용하는가?

동적 계획법은 **Optimal Substructure**에서 효과를 발휘합니다.

**Optimal Substructure** : 답을 구하기 위해 이미 했던 똑같은 계산을 계속 반복하는 문제 구조

---

## 3. 접근 방식

커다란 문제를 쉽게 해결하기 위해 작게 쪼개서 해결하는 방법인 **분할 정복**과 매우 유사합니다. 하지만 간단한 문제로 만드는 과정에서 중복 여부에 대한 차이점이 존재합니다.

즉, 동적 계획법은 간단한 작은 문제들 속에서 **'계속 반복되는 연산'**을 활용하여 빠르게 풀 수 있는 것이 핵심입니다.

### 분할 정복 vs 동적 계획법

| 구분 | 분할 정복 | 동적 계획법 |
|------|-----------|-------------|
| 중복 부분 문제 | 없음 | 있음 |
| 메모이제이션 | 불필요 | 필수 |
| 예시 | 병합 정렬, 퀵 정렬 | 피보나치, 배낭 문제 |

---

## 4. 조건

1. **작은 문제에서 반복이 일어남**
2. **같은 문제는 항상 정답이 같음**

이 두 가지 조건이 충족한다면, 동적 계획법을 이용하여 문제를 풀 수 있습니다.

같은 문제가 항상 정답이 같고, 반복적으로 일어난다는 점을 활용해 **메모이제이션(Memoization)**으로 큰 문제를 해결해나가는 것입니다.

---

## 5. 메모이제이션(Memoization)

**한 번 계산한 문제는 다시 계산하지 않도록 저장해두고 활용하는 방식**

### 피보나치 수열 예시

피보나치 수열에서 재귀를 활용하여 풀 경우, 같은 연산을 계속 반복함을 알 수 있습니다.

```
fibonacci(5) = fibonacci(4) + fibonacci(3)
fibonacci(4) = fibonacci(3) + fibonacci(2)
fibonacci(3) = fibonacci(2) + fibonacci(1)
```

이때, 메모이제이션을 통해 같은 작업을 되풀이 하지 않도록 구현하면 효율적입니다.

이처럼 같은 연산이 계속 반복적으로 이용될 때, 메모이제이션을 활용하여 값을 미리 저장해두면 효율적입니다.

**시간복잡도 개선**
- 일반 재귀: O(2^n)
- 동적 계획법: O(N)

---

## 6. 구현 방식

### 6.1 Bottom-up (상향식)
**작은 문제부터 차근차근 구하는 방법**

```kotlin
// 피보나치 Bottom-up 방식
fun fibonacciBottomUp(n: Int): Long {
    if (n <= 1) return n.toLong()
    
    val dp = LongArray(n + 1)
    dp[0] = 0
    dp[1] = 1
    
    for (i in 2..n) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }
    
    return dp[n]
}
```

**장점**: 해결이 용이함
**단점**: 가독성이 떨어짐

### 6.2 Top-down (하향식)
**큰 문제를 풀다가 풀리지 않은 작은 문제가 있다면 그때 해결하는 방법 (재귀 방식)**

```kotlin
// 피보나치 Top-down 방식
class FibonacciTopDown {
    private val memo = mutableMapOf<Int, Long>()
    
    fun fibonacci(n: Int): Long {
        if (n <= 1) return n.toLong()
        
        if (memo.containsKey(n)) {
            return memo[n]!!
        }
        
        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)
        return memo[n]!!
    }
}
```

**장점**: 가독성이 좋음
**단점**: 코드 작성이 힘듦, 재귀 호출 스택 오버플로우 위험

---

## 7. 문제 해결 접근법

동적 계획법으로 문제를 풀 때는, **우선 작은 문제부터 해결해나가보는 것**이 좋습니다.

1. 작은 문제들을 풀어나가기
2. 이전에 구해둔 더 작은 문제들이 활용되는 것을 확인
3. 규칙을 찾아 점화식 도출
4. 동적 계획법 적용

### 단계별 접근법

1. **문제를 작은 단위로 나누기**
2. **점화식 찾기** (점화식: 이전 계산 결과를 이용해 현재 값을 구하는 식)
3. **기저 조건 설정**
4. **메모이제이션 구현**

## 8. 연습 문제

- **[1463번 - 1로 만들기](https://www.acmicpc.net/problem/1463)** (실버 III)
- **[9251번 - LCS](https://www.acmicpc.net/problem/9251)** (골드 V)
- **[12865번 - 평범한 배낭](https://www.acmicpc.net/problem/12865)** (골드 V)
