# 화면 전환 지연 문제 해결

> 커스텀한 연락처 목록 화면으로 이동하는 과정에서 약 1초정도 화면이 멈춘 뒤,  
> 연락처 목록이 다 불러오고 나서 화면이 전환되는 문제가 발생했습니다.  
> 로딩화면도 나오지 않았고, 화면전환이 부드럽게 안되고 있었습니다.  
> 연락처 목록을 불러오는 연산에 대해 의심하게 되었고, 그걸 해결하는 과정에 대해 정리한 문서입니다.

---

## 1. 문제 상황

### 증상
- **NearListModuleBackground 클릭** → 권한 허용 → Contact 화면 전환이 매우 느림
- 연락처를 모두 로드한 뒤에 부자연스럽게 화면이 전환됨

### 발생 위치
```kotlin
// FriendContactCycleScreen.kt
ContactPermissionRequester(
    onGranted = {
        if (shouldCheckPermission) {
            shouldCheckPermission = false
            onNavigateToContact()  // 여기서 느림
        }
    },
    ...
)
```

---

## 2. 원인 분석

### 2.1 첫 번째 가설: Repository가 느린가?
**가설**: `contactRepository.fetchAllContacts()`가 DB 조회가 느려서 문제인 것 같다.

**시도**: Repository만 격리해서 테스트

```kotlin
// ContactViewModel.kt - Repository 격리 테스트
// Repository 호출을 주석처리하고 빈 데이터로 테스트
// val contactsFlow = contactRepository.fetchAllContacts()

// 빈 Flow로 대체하여 테스트
val contactsFlow = flowOf(emptyList<Contact>())
```

**결과**: **여전히 느림!** Repository 자체는 빠르게 동작하였습니다.

**결론**: Repository는 문제가 아니었음

---

### 2.2 두 번째 가설: uiState 자체가 문제?
**가설**: uiState의 combine과 무거운 연산들이 문제인 것 같다.

**테스트 방법**: ContactViewModel의 모든 연산을 주석처리하고 빈 리스트 반환

```kotlin
// ContactViewModel.kt - 테스트 코드
val uiState: StateFlow<ContactUiState> = 
    MutableStateFlow(
        ContactUiState.Success(
            contacts = emptyMap(),  // 빈 맵
        )
    ).asStateFlow()
```

**결과**: 화면이 **즉시** 전환되었습니다.

**결론**: uiState의 combine과 연산들이 메인 스레드를 블로킹하고 있었음!

---

### 2.3 무거운 연산 식별

```kotlin
// ContactViewModel.kt - 문제가 있던 코드
val uiState: StateFlow<ContactUiState> =
    combine(
        contactsFlow,              // 1. 연락처 로드
        selectedIds,
        _searchQuery,
    ) { contacts, selectedIds, query ->
        contacts
            .filter { ... }        // 2. 필터링
            .map { ... }           // 3. 매핑
            .groupBy { ... }       // 4. 그룹화
            .toSortedMap { ... }   // 5. 정렬
        
        ContactUiState.Success(contacts = sorted)
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000L),
        ContactUiState.Loading,
    )
```

**문제점**:
1. 무거운 연산들이 **메인 스레드나 UI 스레드를 블로킹**할 가능성
2. 연산이 완료되어야 화면 전환이 가능
3. 연락처가 많을수록 더 느려짐

---

### 2.4 핵심 문제 발견: 왜 Loading 초기값이 무시됐나?

**의문점**: 
```kotlin
.stateIn(
    viewModelScope,
    SharingStarted.WhileSubscribed(5000L),
    ContactUiState.Loading,  // 초기값이 설정되어 있는데 왜 안 보였을까?
)
```

**원인**:

1. **스레드 블로킹 문제**
   ```kotlin
   // Before
   권한 허용 클릭 (메인 스레드)
       ↓
   Navigation 시작 (메인 스레드)
       ↓
   ContactViewModel 생성 (메인 스레드)
       ↓
   contactsFlow 시작 (스레드 블로킹 가능성)
       ↓
   combine 연산 (무거운 연산으로 인한 블로킹)
       ↓ (여기까지 UI 스레드가 블로킹됨)
   Success 상태 방출
       ↓
   화면 렌더링 시작 (이제야.............!!!!!!!!!!)
   ```

2. **왜 이전 화면에서 멈춰있었나?**
   - UI 스레드가 블로킹되어 있으면 **Navigation과 화면 렌더링이 불가능**
   - Android는 UI 업데이트를 메인 스레드에서만 할 수 있음
   - 따라서 이전 화면(FriendContactCycle)에 **멈춰있는 것처럼** 보임
   - 실제로는 백그라운드에서 데이터를 로드하고 있었음

3. **왜 Success일 때만 화면이 전환됐나?**
   ```kotlin
   combine(contactsFlow, ...) { ... }  // 첫 번째 값이 나올 때까지 아무것도 방출 안 함
   ```
   - `combine`은 모든 Flow가 **최소 한 번씩 값을 방출해야** 첫 결과를 내보냄
   - `contactsFlow`가 DB 조회를 완료해야 combine이 시작됨
   - 이 모든 과정이 UI 스레드를 블로킹하여 화면 전환이 **지연**됨
   - Success 상태가 되어야 UI 스레드가 해제되고, 그제야 화면 전환 가능

> 초기값 `Loading`은 설정되어 있었지만,  
> UI 스레드가 블로킹되어 화면 전환 자체가 불가능했다!

---

## 3. 해결 방법

### 전략
1. **화면 전환을 먼저** (Loading 상태 표시)
2. **무거운 연산은 백그라운드**에서 실행
3. **데이터 로드 완료 후** Success 상태로 전환

### 3.1 해결

**문제**: 메인 스레드 블로킹  
**해결**: `.flowOn(Dispatchers.Default)` - 무거운 연산을 백그라운드로 이동

이렇게 하면:
```kotlin
권한 허용 클릭 (메인 스레드)
    ↓
Navigation 시작 (메인 스레드) 블로킹 없음!
    ↓
ContactViewModel 생성 (메인 스레드) 블로킹 없음!
    ↓
stateIn 초기값 Loading 설정 (메인 스레드) 즉시!
    ↓
화면 전환 완료! (메인 스레드) 즉시!
    ↓
Loading Indicator 표시
    ↓
[백그라운드] contactsFlow 시작 (Dispatchers.Default)
    ↓
[백그라운드] combine 연산 (Dispatchers.Default)
    ↓
Success 상태로 전환
    ↓
연락처 리스트 표시
```

### 3.2 구현

```kotlin
// ContactViewModel.kt - 수정된 코드
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.flowOn

val uiState: StateFlow<ContactUiState> =
    combine(
        contactsFlow,
        selectedIds,
        _searchQuery,
    ) { contacts, selectedIds, query ->
        // 무거운 연산: filter, map, groupBy, sort
        val filtered = if (query.isBlank()) {
            contacts
        } else {
            contacts.filter { contact ->
                contact.name.contains(query, ignoreCase = true)
            }
        }

        val uiContacts = filtered.map { contact ->
            SelectedContactUiState(
                contact = contact,
                isSelected = contact.id in selectedIds,
            )
        }

        // groupBy → 정렬된 Map 으로 변환
        val grouped = uiContacts.groupBy { getInitial(it.contact.name) }
        val sorted = grouped.toSortedMap(initialComparator)

        ContactUiState.Success(
            contacts = sorted,
        )
    }
    .flowOn(Dispatchers.Default)  // 백그라운드 스레드에서 실행 (이부분만 수정정)
    .stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000L),
        ContactUiState.Loading,
    )
```

---

## 4. 해결 결과

- **화면 전환 시간**: 2-3초 → 즉시 전환
- **메인 스레드 블로킹**: 있음 → 없음

---
