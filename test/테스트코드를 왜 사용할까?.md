# 테스트코드를 왜 사용할까?

> 테스트코드는 소프트웨어의 품질을 보장하고 안정적인 개발을 위한 요소입니다.    
> 테스트코드를 사용하는 이유와 테스트의 종류, 그리고 효과적인 테스트 전략에 대해 알아보겠습니다.  

---

## 1. 테스트코드를 사용하는 주요 이유

개발 단계에서 버그를 발견하는 것이 프로덕션 환경에서 발견하는 것보다 훨씬 비용이 적게 듭니다.

---

## 2. 테스트코드의 종류

### 2.1 Unit Test (단위 테스트)

**목적**: 개별 함수, 메서드, 클래스의 동작을 검증

**특징**:
- 가장 빠르게 실행됨
- 외부 의존성 없이 독립적으로 실행
- 가장 많이 작성해야 함 (테스트 피라미드의 70%)

```kotlin
class StringUtilsTest {
    
    @Test
    fun `문자열이 숫자로만 이루어져 있으면 true를 반환한다`() {
        // Arrange
        val inputNumericString = "12345"
        
        // Act
        val actualResult = StringUtils.isNumeric(inputNumericString)
        
        // Assert
        assertTrue(actualResult)
    }
    
    @Test
    fun `문자열에 문자가 포함되어 있으면 false를 반환한다`() {
        // Arrange
        val inputAlphaNumericString = "123abc"
        
        // Act
        val actualResult = StringUtils.isNumeric(inputAlphaNumericString)
        
        // Assert
        assertFalse(actualResult)
    }
}
```

---

### 2.2 Integration Test (통합 테스트)

**목적**: 여러 컴포넌트가 함께 동작하는 것을 검증

**특징**:
- 데이터베이스, API 등 실제 의존성과 통합 테스트
- Unit Test보다 느리지만 더 현실적
- 테스트 피라미드의 20%

```kotlin
@RunWith(AndroidJUnit4::class)
class UserRepositoryIntegrationTest {
    
    private lateinit var userRepository: UserRepository
    private lateinit var database: AppDatabase
    
    @Before
    fun setUp() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        
        // 테스트용 인메모리 데이터베이스 생성
        database = Room.inMemoryDatabaseBuilder(
            context,
            AppDatabase::class.java
        ).build()
        
        userRepository = UserRepositoryImpl(
            userDao = database.userDao(),
            userApi = mockk()
        )
    }
    
    @After
    fun tearDown() {
        database.close()
    }
    
    @Test
    fun `사용자를 저장하고 조회하면 같은 데이터를 반환한다`() = runTest {
        // Arrange
        val inputUser = User(
            id = "1",
            email = "test@example.com",
            name = "홍길동"
        )
        
        // Act: 저장
        userRepository.saveUser(inputUser)
        
        // Act: 조회
        val actualUser = userRepository.getUser(inputUser.id).getOrNull()
        
        // Assert
        assertNotNull(actualUser)
        assertEquals(inputUser.id, actualUser?.id)
        assertEquals(inputUser.email, actualUser?.email)
        assertEquals(inputUser.name, actualUser?.name)
    }
}
```

---

### 2.3 UI Test (UI 테스트)

**목적**: 사용자 인터페이스의 동작을 검증

**특징**:
- 실제 사용자의 행동을 시뮬레이션
- 가장 느리지만 가장 현실적
- 테스트 피라미드의 10%

```kotlin
@RunWith(AndroidJUnit4::class)
class LoginActivityTest {
    
    @get:Rule
    val activityRule = ActivityScenarioRule(LoginActivity::class.java)
    
    @Test
    fun `올바른 이메일과 비밀번호를 입력하고 로그인하면 홈 화면으로 이동한다`() {
        // Arrange & Act: 이메일 입력
        onView(withId(R.id.editTextEmail))
            .perform(typeText("test@example.com"))
        
        // Act: 비밀번호 입력
        onView(withId(R.id.editTextPassword))
            .perform(typeText("password123"))
        
        // Act: 키보드 닫기
        closeSoftKeyboard()
        
        // Act: 로그인 버튼 클릭
        onView(withId(R.id.buttonLogin))
            .perform(click())
        
        // Assert: 홈 화면으로 이동했는지 확인
        intended(hasComponent(HomeActivity::class.java.name))
    }
    
    @Test
    fun `이메일을 입력하지 않고 로그인하면 에러 메시지를 표시한다`() {
        // Act: 이메일 입력 없이 로그인 버튼 클릭
        onView(withId(R.id.buttonLogin))
            .perform(click())
        
        // Assert: 에러 메시지 확인
        onView(withId(R.id.textViewError))
            .check(matches(isDisplayed()))
            .check(matches(withText("이메일을 입력해주세요")))
    }
}
```

---

## 3. 테스트 피라미드

좋은 테스트 전략은 다음과 같은 비율을 따릅니다:

```
       /\
      /UI\      10% - UI Tests (느림, 비용 높음)
     /----\
    /Integ.\   20% - Integration Tests (보통)
   /--------\
  /   Unit   \ 70% - Unit Tests (빠름, 비용 낮음)
 /------------\
```

### 왜 이런 비율일까?

1. **Unit Test (70%)**
   - 가장 빠르게 실행됨
   - 버그의 정확한 위치를 찾기 쉬움
   - 유지보수 비용이 낮음
   - 개발 중에 자주 실행 가능

2. **Integration Test (20%)**
   - 컴포넌트 간 상호작용 검증
   - 실제 환경에 가까운 테스트
   - Unit Test로는 발견하기 어려운 버그 발견

3. **UI Test (10%)**
   - 전체 플로우 검증
   - 사용자 관점에서 가장 중요한 시나리오만 테스트
   - 가장 느리고 유지보수 비용이 높음

---
